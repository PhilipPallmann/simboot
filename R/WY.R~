WY <-
function(X, f, theta, cmat, conf.level, alternative, R, args)
  {
    bargs <- args
    dat <- estThetaRow(X = X, f = f, theta = theta)
    linmod <- lm(dat$inds ~ dat$fac -1)
    res <- residuals(linmod)
    resdat <- data.frame(x = res, y = dat$fac)
    names(resdat) <- c("res", "fac")
    coeff <- coefficients(linmod)
    estres <- function(X, f, coeff, cmat)
      {
        eres <- coeff
        ssq <- tapply(X, f, FUN = function(x){sum((x - mean(x))^2)})
        dfd <- tapply(X, f, FUN = function(x){length(x) - 1})
        evar <- sum(ssq) / sum(dfd)
        ni <- tapply(X, f, FUN = length)
        estC <- cmat %*% eres
        varC <- (cmat^2) %*% (evar / ni)
        return(list(
                    estC = estC,
                    varC = varC
                    )
               )

      }
    EST <- estres(X = dat$inds, f = dat$fac, coeff = coeff, cmat = cmat)
    ResTeststat <- function(X, i, f, cmat)
      {
        RNEW <- X[i]
        eresB <- tapply(X = RNEW, INDEX = f, FUN = mean)
        ssqB <- tapply(X = RNEW, INDEX = f, FUN = function(x){sum((x - mean(x))^2)})
        dfdB <- tapply(X = RNEW, INDEX = f, FUN = function(x){length(x) - 1})
        evarB <- sum(ssqB) / sum(dfdB)
        niB <- tapply(X = RNEW, INDEX = f, FUN = length)
        estCB <- cmat %*% eresB
        varCB <- (cmat^2) %*% (evarB / niB)
        teststatB <- estCB / sqrt(varCB)
        return(teststatB = teststatB)
      }
    bargs$data <- resdat$res
    bargs$R <- R
    bargs$statistic <- ResTeststat
    bargs$f <- resdat$fac
    bargs$cmat <- cmat
    if(is.null(bargs$sim))
      {
        bargs$sim <- "ordinary"
      }
    if(is.null(bargs$stype))
      {
        bargs$stype <- "i"
      }
    bootout <- do.call("boot", bargs)
    teststat <- bootout$t
    alpha <- 1 - conf.level
    switch(alternative,
           "two.sided" =
           {
             maxabsT <- apply(X = bootout$t, MARGIN = 1, FUN = function(x){max(abs(x))})
             quant <- quantile(maxabsT, probs = 1-alpha, na.rm = T)
             LOWER <- EST$estC - quant * sqrt(EST$varC)
             UPPER <- EST$estC + quant * sqrt(EST$varC)
           },
           "less" =
           {
             maxT <- apply(X = bootout$t, MARGIN = 1, FUN = max)
             quant <- quantile(maxT, probs = 1-alpha, na.rm = T)
             LOWER <- NA
             UPPER <- EST$estC + quant * sqrt(EST$varC)
           },
           "greater" =
           {
             minT <- apply(X = bootout$t, MARGIN = 1, FUN = min)
             quant <- quantile(minT, probs = alpha, na.rm = T)
             LOWER <- EST$estC + quant * sqrt(EST$varC)
             UPPER <- NA
           })
    conf.int <- cbind(EST$estC, LOWER, UPPER)
    colnames(conf.int) <- cbind("estimate", "lower", "upper")
    return(list(conf.int=conf.int, conf.level = conf.level, alternative = alternative))
  }

